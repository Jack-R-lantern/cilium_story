# [ISSUE-25657](https://github.com/cilium/cilium/issues/25657) - Improve Hubble decoding performance

## 연관 이슈/PR
* [PR-24162](https://github.com/cilium/cilium/pull/24162)
---

## 이슈 내용
`encoding/binary`의 `binary.Read`를 이용한 decoding 과정에서의 성능 이슈로 인한 개선 작업이 필요한 상황.


## PR 제출 여부
[PR-25751](https://github.com/cilium/cilium/pull/25751)

---
## [학습 내용 링크](learning.md)
---

## code analyzes

### 문제가 발생한 코드 부분
* [DropNotify](https://github.com/cilium/cilium/blob/82a6396d59f5b52cbbb8a3787803cd2317ffdaf0/pkg/hubble/parser/threefour/parser.go#L112)
	```go
	dn = &monitor.DropNotify{}
			if err := binary.Read(bytes.NewReader(data), byteorder.Native, dn); err != nil {
				return fmt.Errorf("failed to parse drop: %v", err)
			}
	```
	`binary.Read`를 호출 하는 부분에서 성능 문제가 발생함. \
	`binary.Read`가 어떻게 동작하는지 정확히 파악할 필요가 있음.

### encoding/binary/binary.go
* [binary.Read](https://cs.opensource.google/go/go/+/refs/tags/go1.20.5:src/encoding/binary/binary.go;l=229)
	```go
	func Read(r io.Reader, order ByteOrder, data any) error {
		// Fast path for basic types and slices.
		if n := intDataSize(data); n != 0 {
			bs := make([]byte, n)
			if _, err := io.ReadFull(r, bs); err != nil {
				return err
			}
			switch data := data.(type) {
			case *bool:
				*data = bs[0] != 0
			case *int8:
				*data = int8(bs[0])

			...

			case []bool:
				for i, x := range bs { // Easier to loop over the input for 8-bit values.
					data[i] = x != 0
				}
			case []int8:
				for i, x := range bs {
					data[i] = int8(x)
				}

			...

			default:
				n = 0 // fast path doesn't apply
			}
			if n != 0 {
				return nil
			}
		}
		// Fallback to reflect-based decoding.
		v := reflect.ValueOf(data)
		size := -1
		switch v.Kind() {
		case reflect.Pointer:
			v = v.Elem()
			size = dataSize(v)
		case reflect.Slice:
			size = dataSize(v)
		}
		if size < 0 {
			return errors.New("binary.Read: invalid type " + reflect.TypeOf(data).String())
		}
		d := &decoder{order: order, buf: make([]byte, size)}
		if _, err := io.ReadFull(r, d.buf); err != nil {
			return err
		}
		d.value(v)
		return nil
	}
	```
	`binary.Read` 함수 자체는 `primitive type`에 한해 최적화를 진행해 빠르게 처리가 가능함.\
	하지만 범용성을 지원하기 위해 `primitive type`이 아닌 경우 `reflect`를 이용한 타입 추론을 진행함.\
	특정 구조체를 빈번하게 디코딩 하게 되면 하나의 병목 지점으로 작용 할 수 있음.

## 해결 과정
### [BPF - MAP](https://github.com/cilium/cilium/blob/main/bpf/lib/events.h)
```c
struct {
	__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
	__uint(key_size, sizeof(__u32));
	__uint(value_size, sizeof(__u32));
	__uint(pinning, LIBBPF_PIN_BY_NAME);
	__uint(max_entries, __NR_CPUS__);
} EVENTS_MAP __section_maps_btf;
```
`cilium`은 설정한 이벤트를 `userspace`에서 접근할수 있게 위의 구조체 기반의 `bpf_map`을 사용하고 있음.\
해당 코드는 `bpf/lib/events.h`에 위치함.

### BPF - EVENT NOTIFY
* drop_notify
	```c
	struct drop_notify {
		NOTIFY_CAPTURE_HDR
		__u32		src_label;
		__u32		dst_label;
		__u32		dst_id; /* 0 for egress */
		__u16		line;
		__u8		file;
		__s8		ext_error;
		__u32		ifindex;
	};
	```
* policy_verdicy_notify
	```c
	struct policy_verdict_notify {
		NOTIFY_CAPTURE_HDR
		__u32	remote_label;
		__s32	verdict;
		__u16	dst_port;
		__u8	proto;
		__u8	dir:2,
			ipv6:1,
			match_type:3,
			audited:1,
			pad0:1;
		__u8	auth_type;
		__u8	pad1; /* align with 64 bits */
		__u16	pad2; /* align with 64 bits */
	};
	```
* debug_capture_msg
	```c
	struct debug_capture_msg {
		NOTIFY_CAPTURE_HDR
		__u32		arg1;
		__u32		arg2;
	};
	```
* debug_msg
	```c
	struct debug_msg {
		NOTIFY_COMMON_HDR
		__u32		arg1;
		__u32		arg2;
		__u32		arg3;
	};
	```
* trace_notify
	```c
	struct trace_notify {
		NOTIFY_CAPTURE_HDR
		__u32		src_label;
		__u32		dst_label;
		__u16		dst_id;
		__u8		reason;
		__u8		ipv6:1;
		__u8		pad:7;
		__u32		ifindex;
		union {
			struct {
				__be32		orig_ip4;
				__u32		orig_pad1;
				__u32		orig_pad2;
				__u32		orig_pad3;
			};
			union v6addr	orig_ip6;
		};
	};
	```
`cilium`은 config에 따라 이벤트를 추적할때 위의 구조체를 사용하며 위의 구조체는 `EVENT_MAPS`에 저장됨.

### pkg/monitor/datapath_xxx.go
* DropNotify
	```go
	// DropNotify is the message format of a drop notification in the BPF ring buffer
	type DropNotify struct {
		...
	}
	```
	* location: `pkg/monitor/datapath_drop.go`
	* data_length: 36
* PolicyVerdictNotify
	```go
	// PolicyVerdictNotify is the message format of a policy verdict notification in the bpf ring buffer
	type PolicyVerdictNotify struct {
		...
	}
	```
	* location: `pkg/monitor/datapath_policy.go`
	* data_length: 32
* DebugCapture
	```go
	// DebugCapture is the metadata sent along with a captured packet frame
	type DebugCapture struct {
		...
	}
	```
	* location: `pkg/monitor/datapath_debug.go`
	* data_length: 24
* DebugMsg
	```go
	// DebugMsg is the message format of the debug message found in the BPF ring buffer
	type DebugMsg struct {
		...
	}
	```
	* location: `pkg/monitor/datapath_debug.go`
	* data_length: 20
* TraceSockNotify
	```go
	// TraceSockNotify is message format for socket trace notifications sent from datapath.
	// Keep this in sync to the datapath structure (trace_sock_notify) defined in
	// bpf/lib/trace_sock.h
	type TraceSockNotify struct {
		...
	}
	```
	* location: `pkg/monitor/datapath_sock_trace.go`
	* data_length: 38

`golang`에 선언된 5개의 구조체는 `bpf`에서 사용하는 5개의 구조체를 디코딩 할 수 있어야 함.\
`data_length` 부분으로 유효성 검사를 하는 로직이 필요한것을 확인 할 수 있음.
